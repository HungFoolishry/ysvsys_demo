# 首先是普通的摩尔投票法
首先我们了解下什么是摩尔投票法:其基于一个**事实**: 当数组中存在某个数个数大于数组长度的**1/2**
时，我们可以使用使用摩尔投票法找出这个数。

算法：设置一个候选人和一个计数器count。遍历数组，每次遇到和候选人一样的值则count + 1，否
则count - 1.当count == 0 时替换候选人。最后剩下的就是我们所求的众数。 

那么为什么能这样求呢？首先我们可以把数组中的数分为两类：**众数和其他数**。
算法中遇到和候选人不一样的值进行count - 1时其实可以看成一次**互拼**。而我们**必须要保证**这个互拼只有以下2种情况：
1.众数和其他数互拼，两者同时消耗1.
2.其他数和其他数互拼，其他数消耗2.
如果我们想要最后剩下的都是众数，那么按照对众数最不利的情况是所有的互拼都是情况1.而由于众数的个数大于2/n，所以最不利的情况最后留下来的也是众数。
而在**算法中我们保证互拼只有以上2种情况的方法**就是：**我们遇到相同的候选人则count+1，这样可以避免众数和众数互拼**(因为众数肯定是相等的，所以相同的时候count++就避免了众数和众数互拼)
题目：[169.多数元素](https://leetcode-cn.com/problems/majority-element/comments/)

# 我们回到本题：
本题是求个数**大于长度1/3**的所有数。假设数组长度为n,那么我们稍微思考可以得出结论**个数超过3/n的数不会超过2个**。
算法思想是设置两个候选人以及两个计数器。遍历到和候选人相同时则**对应计数器+1**，如果和两个候选人都不相同则**两个计数器都-1**，当一个计数器为0时，更换对应的候选人。遍历完剩下的则是2个众数。
同上面分析，为何我们可以这么做？此题我们可以分成三类数： **众数一、众数二和其他数**。
和上面思想一样，遍历时遇到和两个候选人都不一样的值，则是一次**互拼**，我们必须要保证这两种情况：
1.众数一，众数二，其他数 三者拼，都消耗1。
2.某众数，和2个其他数 三者拼，某众数消耗1，其他数消耗2.
和**上述同样的分析方法**可以得出最后剩下的一定是2个众数。





```java
public List<Integer> majorityElement(int[] nums) {
        int res1 = nums[0], res2 = nums[0], count1 = 0, count2 = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == res1) {
                count1++;
            } else if (nums[i] == res2) {
                count2++;
            } else if (count1 == 0) {
                // 当前数与2个候选人都不一样且count等于0则更换候选人
                res1 = nums[i];
                count1++;
            } else if (count2 == 0) {
                res2 = nums[i];
                count2++;
            } else {
                // 非候选人 且 count != 0
                count1--;
                count2--;
            }
        }
        // 本题未保证一定存在2个候选人,因此还需要遍历一次确认是否大于1/3
        count1 = 0;
        count2 = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == res1)
                count1++;
            else if (nums[i] == res2)
                count2++;
        }
        List<Integer> res = new ArrayList<>();
        if (count1 > nums.length / 3)
            res.add(res1);
        if (count2 > nums.length / 3)
            res.add(res2);
        return res;
    }
```
